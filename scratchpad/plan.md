# bracketeer

An R package for building tournament brackets.

## Goal

Implement all known tournament styles and variations in an easy-to-use format using base R with no dependencies.

---

## R Package Structure

```
bracketeer/
├── DESCRIPTION
├── NAMESPACE
├── LICENSE
├── R/
│   ├── bracket.R          # Core bracket class and methods
│   ├── single_elim.R      # Single elimination
│   ├── double_elim.R      # Double elimination
│   ├── round_robin.R      # Round robin
│   ├── swiss.R            # Swiss system
│   ├── seeding.R          # Seeding algorithms
│   ├── utils.R            # Helper functions
│   └── print.R            # Print/display methods
├── man/                   # Documentation (generated by roxygen2)
├── tests/
│   └── testthat/
└── vignettes/             # Long-form documentation
```

---

## Tournament Types to Implement

### Phase 1: Core Formats
1. **Single Elimination** - Standard knockout bracket
2. **Double Elimination** - Winners/losers bracket with grand final
3. **Round Robin** - Everyone plays everyone

### Phase 2: Advanced Formats
4. **Swiss System** - Pairing by similar records
5. **Group Stage + Knockout** - Groups into single/double elim
6. **Best-of-N Series** - Multi-game matches within brackets

### Phase 3: Variations
7. **Seeded brackets** - Standard, random, snake draft
8. **Byes** - Handle non-power-of-2 participant counts
9. **Third-place match** - Optional consolation finals
10. **Reseeding** - Reseed after each round

---

## Core Data Structures

### Participant
```r
# Simple character vector or data.frame with metadata
participants <- c("Team A", "Team B", "Team C", "Team D")

# Or with seeds/ratings
participants <- data.frame(
  name = c("Team A", "Team B", "Team C", "Team D"),
  seed = c(1, 2, 3, 4),
  rating = c(1500, 1450, 1400, 1350)
)
```

### Match
```r
# S3 class
match <- list(
  id = 1,
  round = 1,
  participant1 = "Team A",
  participant2 = "Team D",
  score1 = NA,
  score2 = NA,
  winner = NA,
  next_match = 2  # ID of next match winner advances to
)
class(match) <- "bracket_match"
```

### Bracket
```r
# S3 class containing all matches
bracket <- list(
  type = "single_elimination",
  participants = participants,
  matches = list(...),
  rounds = 3,
  current_round = 1
)
class(bracket) <- c("single_elim_bracket", "bracket")
```

---

## Core Functions

### Creation
```r
# Generic constructor
bracket(participants, type = "single_elim", seed = TRUE, ...)

# Type-specific constructors
single_elim(participants, seed = TRUE, third_place = FALSE)
double_elim(participants, seed = TRUE, grand_final_reset = TRUE)
round_robin(participants, home_away = FALSE)
swiss(participants, rounds = NULL)
```

### Manipulation
```r
# Record match results
set_result(bracket, match_id, score1, score2)
set_winner(bracket, match_id, winner)

# Advance tournament state
advance(bracket)  # Progress to next round if current complete

# Query state
get_matches(bracket, round = NULL, status = c("pending", "complete", "all"))
get_standings(bracket)
get_winner(bracket)
is_complete(bracket)
```

### Display
```r
print(bracket)           # Text summary
summary(bracket)         # Statistics
# Future: plot(bracket)  # Visual bracket (would need dependencies)
```

---

## Implementation Plan

### Step 1: Package Skeleton
- [ ] Create DESCRIPTION file
- [ ] Create NAMESPACE file
- [ ] Set up R/ directory

### Step 2: Core Infrastructure
- [ ] Define S3 classes (bracket, match)
- [ ] Implement generic `bracket()` constructor
- [ ] Implement `print.bracket()` method
- [ ] Implement utility functions (seeding, bye handling)

### Step 3: Single Elimination
- [ ] `single_elim()` constructor
- [ ] Generate bracket structure with proper seeding
- [ ] `set_result()` for single elim
- [ ] Handle byes for non-power-of-2
- [ ] Optional third-place match

### Step 4: Double Elimination
- [ ] Winners bracket generation
- [ ] Losers bracket generation
- [ ] Grand final (with optional bracket reset)
- [ ] Track which bracket each match belongs to

### Step 5: Round Robin
- [ ] Schedule generation (circle method)
- [ ] Standings calculation (wins, losses, ties, point diff)
- [ ] Tiebreaker logic

### Step 6: Swiss System
- [ ] Pairing algorithm (avoid rematches, pair similar records)
- [ ] Bye handling for odd numbers
- [ ] Standings with tiebreakers

### Step 7: Testing & Documentation
- [ ] Unit tests for each tournament type
- [ ] Roxygen documentation for all exported functions
- [ ] Vignette with examples

---

## Example API Usage

```r
library(bracketeer)

# Create a 16-team single elimination bracket
teams <- paste("Team", LETTERS[1:16])
b <- single_elim(teams, seed = TRUE)
print(b)

# Record results
b <- set_result(b, match_id = 1, score1 = 3, score2 = 1)
b <- set_result(b, match_id = 2, score1 = 0, score2 = 2)

# Check current state
get_matches(b, round = 1, status = "pending")
get_standings(b)

# Double elimination example
b2 <- double_elim(teams[1:8])
b2 <- set_winner(b2, match_id = 1, winner = "Team A")

# Round robin example
b3 <- round_robin(teams[1:6])
schedule <- get_matches(b3)
```

---

## Notes

- Use S3 classes for simplicity and base R compatibility
- All functions should be vectorized where sensible
- Return modified bracket objects (functional style, not modify-in-place)
- Consistent naming: snake_case for functions, lowercase for arguments

