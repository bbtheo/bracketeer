---
title: "Fresh API Brainstorm — Graph Mode"
format: html
---

# Design Principle

A tournament definition should read like a rulebook.
A tournament runtime should feel like a scoreboard.

---

# Resolved Decisions

1. **Auto-advance is the default.** Manual `advance()` is opt-in via
   `tournament(teams, auto_advance = FALSE)`.
2. **Formula syntax (`"A" ~ "B"`)** for participant addressing is on the
   roadmap, not MVP.
3. **`score = c(2, 1)`** — single vector, not separate `score1` / `score2`.
4. **Stage verbs always build a spec-like object internally.** `tournament()` is
   sugar for `spec() |> build(teams)`. Dispatch stays simple.
5. **Avoid name collisions.** Use `top_n()`, `bottom_n()`, `slice_range()`,
   `stage_status()`. Keep `remaining()`, `losers()`, `matches()`, `standings()`,
   `winner()`, `rankings()` — these are domain-specific enough.
6. **`from` defaults to `previous_stage()`.** In a linear chain you never need
   to name the source — it's the stage declared immediately before. Explicit
   `from =` is only needed for branching (multiple stages reading from the same
   source) or non-linear graphs.

---

# The Ideal API

## Defining a tournament

Stage types are the verbs. `from` defaults to `previous_stage()` so linear
chains need zero wiring. Branching uses explicit `from =`.

```{r}
#| eval: false
library(bracketeer)

teams <- paste("Team", LETTERS[1:16])

# ── Single-stage (simplest possible) ──
trn <- tournament(teams) |>
  round_robin("groups")

# ── Linear chain (from = previous_stage() is implicit) ──
trn <- tournament(teams) |>
  swiss("open", rounds = 5) |>
  single_elim("top_cut", take = top_n(8))
# "top_cut" automatically reads from "open" — no from = needed.

# ── Branching (explicit from required) ──
trn <- tournament(teams) |>
  round_robin("groups") |>
  single_elim("championship", from = "groups", take = top_n(8)) |>
  single_elim("consolation",  from = "groups", take = remaining())

# ── Deep graph ──
trn <- tournament(teams) |>
  swiss("open", rounds = 9) |>
  single_elim("top_8",    from = "open", take = top_n(8)) |>
  single_elim("mid_tier", from = "open", take = slice_range(9, 16)) |>
  round_robin("bottom",   from = "open", take = remaining())
```

### How `previous_stage()` works

The tournament object tracks stage declaration order. When `from` is omitted (or
explicitly set to `previous_stage()`), it resolves to the most recently declared
stage.

```{r}
#| eval: false
# These two are identical:
tournament(teams) |>
  round_robin("groups") |>
  single_elim("finals", take = top_n(8))

tournament(teams) |>
  round_robin("groups") |>
  single_elim("finals", from = previous_stage(), take = top_n(8))

# Both resolve from = "groups" because "groups" is the previous stage.
```

For longer linear chains this removes a lot of noise:

```{r}
#| eval: false
# Four-stage pipeline — no from = anywhere
trn <- tournament(teams) |>
  round_robin("group_stage") |>
  swiss("swiss_cut", rounds = 3, take = top_n(8)) |>
  double_elim("bracket", take = top_n(4)) |>
  single_elim("grand_final", take = top_n(2))
```

When does `previous_stage()` NOT work?

- **Branching:** two stages reading from the same source. You must name `from`
  explicitly because the pipe only has one "previous."
- **Merging:** a stage fed by multiple upstream stages (future feature).

The rule is simple: if the graph is a straight line, you never write `from`.

---

## The spec path (validation / reuse)

```{r}
#| eval: false
# ── Define without participants ──
my_spec <- spec() |>
  round_robin("groups") |>
  single_elim("championship", from = "groups", take = top_n(8)) |>
  single_elim("consolation",  from = "groups", take = remaining())

# ── Validate ──
validate(my_spec, n = 16)

# ── Build with a specific participant set ──
trn <- my_spec |> build(teams)
```

Same verbs, same pipe chain. `spec()` returns a blueprint without participants.
`build()` materializes it into a live `tournament`.

---

## Entering results

```{r}
#| eval: false
# ── One at a time ──
trn <- trn |> result("groups", match = 1, score = c(2, 1))

# ── Batch from a data frame ──
results_df <- data.frame(
  match = 1:4,
  score1 = c(2, 1, 3, 0),
  score2 = c(1, 0, 2, 1)
)
trn <- trn |> results("groups", results_df)

# ── Roadmap: formula addressing ──
# trn <- trn |> result("groups", "Argentina" ~ "Brazil", score = c(2, 1))
```

`score = c(home, away)` — always a length-2 vector. For best-of series, a
longer vector of game scores.

Auto-advance kicks in automatically: when the last group match is entered,
downstream stages materialize without an explicit `advance()` call.

---

## Manual advance (opt-in)

```{r}
#| eval: false
trn <- tournament(teams, auto_advance = FALSE) |>
  round_robin("groups") |>
  single_elim("championship", from = "groups", take = top_n(8))

# ... enter all group results ...

# Explicitly trigger:
trn <- trn |> advance("groups")
```

---

## Inspecting state

```{r}
#| eval: false
# ── Print ──
trn
# Tournament [3 stages]
#   groups         in_progress   90/120 matches
#   championship   blocked
#   consolation    blocked

# ── Matches ──
matches(trn)                             # all pending, all stages
matches(trn, "groups")                   # pending in groups
matches(trn, "groups", status = "all")   # everything

# ── Standings ──
standings(trn, "groups")

# ── Stage overview ──
stage_status(trn)
#   stage          status       complete  total  materialized
#   groups         in_progress        90    120          TRUE
#   championship   blocked             0      0         FALSE
#   consolation    blocked             0      0         FALSE

# ── Final outcomes ──
winner(trn)
rankings(trn)
```

---

## Routing helpers

```{r}
#| eval: false
top_n(n)             # top n by overall standings
bottom_n(n)          # bottom n by overall standings
slice_range(from, to) # standings positions from:to
remaining()          # everyone not already consumed by a prior transition
losers()             # eliminated participants
filter_by(predicate) # custom predicate on standings data frame

# ── Per-group variants ──
top_per_group(n)     # top n from EACH group
bottom_per_group(n)  # bottom n from each group
```

### Per-group routing: `top_per_group(n)` vs `top_n(n, per_group = TRUE)`

This is the "top 2 from each of 4 groups" pattern — the bread and butter of
World Cup, Champions League, Euro, etc. Two design options:

**Option A — separate verb (recommended):**

```{r}
#| eval: false
top_per_group(2)
```

**Option B — parameter on `top_n()`:**

```{r}
#| eval: false
top_n(2, per_group = TRUE)
```

**Recommendation: separate verb.** Reasons:

1. **Different semantics.** `top_n(8)` takes 8 from one combined ranking.
   `top_per_group(2)` takes 2 from each group's own ranking. These are
   fundamentally different operations — "top 8 overall" vs "top 2 per group"
   can select completely different sets of participants.

2. **Reads like English.** `take = top_per_group(2)` says exactly what it does.
   `take = top_n(2, per_group = TRUE)` buries the important part in a flag.

3. **Fails cleanly.** `top_per_group()` on a non-grouped stage is a clear error:
   "source stage has no groups." With a flag on `top_n()`, the flag silently
   does nothing if the source isn't grouped — or you need extra validation
   logic.

4. **Discoverable.** Autocomplete on `top_` shows both options. With a flag,
   users have to already know the parameter exists.

### Per-group routing in context

`round_robin()` gains a `groups =` parameter for parallel group play within a
single stage node. `top_per_group()` is the natural routing partner:

```{r}
#| eval: false
# ── World Cup: 4 groups of 4, top 2 per group into knockout ──
trn <- tournament(teams) |>
  round_robin("groups", groups = 4) |>
  single_elim("knockout", take = top_per_group(2))

# ── Champions League: 8 groups of 4, top 2 + best 3rd-place ──
trn <- tournament(teams) |>
  round_robin("groups", groups = 8) |>
  single_elim("round_of_16", from = "groups", take = top_per_group(2)) |>
  single_elim("europa_playoff", from = "groups", take = slice_per_group(3, 3))
  # ^ 3rd place from each group into a separate playoff
```

The `_per_group` family:

| Function | Selects |
|----------|---------|
| `top_per_group(n)` | Top n from each group |
| `bottom_per_group(n)` | Bottom n from each group |
| `slice_per_group(from, to)` | Positions from:to within each group |

These only work when the source stage has group structure. If it doesn't, they
error with a clear message. This keeps `top_n()` simple (operates on flat
standings) and `top_per_group()` explicit (operates on grouped standings).

### What about "best third-place teams across groups"?

This is the Euro/World Cup expanded format pattern: top 2 per group qualify
automatically, then the 4 best third-place teams across all groups also qualify.

This is a cross-group comparison — you want the 3rd-place finisher from each
group, then rank them against each other and take the best N. That's a compound
operation:

```{r}
#| eval: false
# Option A: slice_per_group + top_n in a custom rule
best_thirds <- function(source_pool, standings, ...) {
  thirds <- slice_per_group(3, 3)  # 3rd from each group
  # then re-rank across groups and take top 4
  third_standings <- standings[standings$rank == 3, ]
  third_standings <- third_standings[order(-third_standings$points), ]
  third_standings$participant[1:4]
}

# Option B: dedicated helper
best_across_groups(rank = 3, n = 4)
```

Option B is cleaner but very specific. Could be roadmap. For MVP, the custom
rule function handles it — and it's a rare enough pattern that a helper isn't
urgent.

---

# Full API surface (proposed)

## Definition verbs (pipe onto `tournament()` or `spec()`)

| Function | Purpose |
|----------|---------|
| `tournament(participants, auto_advance = TRUE)` | Create live tournament runtime |
| `spec()` | Create a reusable blueprint (no participants) |
| `round_robin(id, ...)` | Add round-robin stage |
| `single_elim(id, ...)` | Add single-elimination stage |
| `double_elim(id, ...)` | Add double-elimination stage |
| `swiss(id, ...)` | Add Swiss-system stage |
| `two_leg(id, ...)` | Add two-leg knockout stage |
| `group_stage_knockout(id, ...)` | Add combined group+knockout stage |

Each stage verb accepts `from =` (default `previous_stage()`) and `take =`
(routing rule, default: all participants from source).

## Routing helpers

| Function | Purpose |
|----------|---------|
| `top_n(n)` | Top n by overall standings |
| `bottom_n(n)` | Bottom n by overall standings |
| `slice_range(from, to)` | Standings positions from:to |
| `top_per_group(n)` | Top n from each group |
| `bottom_per_group(n)` | Bottom n from each group |
| `slice_per_group(from, to)` | Positions from:to within each group |
| `remaining()` | Leftover pool after consuming transitions |
| `losers()` | Eliminated participants |
| `filter_by(fn)` | Custom predicate on standings |
| `previous_stage()` | Sentinel: resolve to prior stage in declaration order |

## Runtime verbs

| Function | Purpose |
|----------|---------|
| `result(trn, stage, match, score)` | Enter one match result |
| `results(trn, stage, df)` | Enter batch results from data frame |
| `advance(trn, stage)` | Manually advance a completed stage |

## Inspection (nouns)

| Function | Purpose |
|----------|---------|
| `matches(trn, stage?, status?)` | Match table (pending/complete/all) |
| `standings(trn, stage?)` | Standings table |
| `stage_status(trn)` | Overview of all stages |
| `winner(trn)` | Tournament winner |
| `rankings(trn)` | Final placement table |
| `routing_log(trn)` | Transition audit trail |

## Spec-only

| Function | Purpose |
|----------|---------|
| `validate(spec, n)` | Preflight feasibility check |
| `build(spec, participants)` | Materialize spec into tournament runtime |

---

# Comparison table

| Task | Current API | Proposed |
|------|-------------|----------|
| Simple tournament | `tournament_spec() |> add_stage("x", round_robin_stage()) |> build_tournament(spec, teams)` | `tournament(teams) |> round_robin("x")` |
| Linear chain | `add_stage() |> add_stage() |> add_transition(from, to, ...)` | `swiss("a") |> single_elim("b", take = top_n(8))` — `from` is implicit |
| Branching | `split_stage(from, into = list(...))` | Two stage verbs with explicit `from = "same_source"` |
| Enter result | `result(trn, "groups", match_id = 1, score1 = 2, score2 = 1)` | `result(trn, "groups", 1, score = c(2, 1))` |
| See matches | `get_matches(trn$stage_state$groups$bracket, status = "pending")` | `matches(trn, "groups")` |
| See standings | `get_standings(trn$stage_state$groups$bracket)` | `standings(trn, "groups")` |
| Advance | `if (is_stage_complete(trn, "groups")) trn <- advance(trn, "groups")` | automatic by default |

---

# End-to-end examples

## World Cup (per-group routing)

```{r}
#| eval: false
teams <- c(
  "Argentina", "Australia", "Brazil", "Croatia",
  "England", "France", "Japan", "Morocco",
  "Netherlands", "Poland", "Portugal", "Senegal",
  "South Korea", "Spain", "Switzerland", "United States"
)

# ── 4 groups of 4, top 2 per group into knockout ──
trn <- tournament(teams) |>
  round_robin("groups", groups = 4) |>
  single_elim("knockout", take = top_per_group(2))

# ── Enter group results ──
group_matches <- matches(trn, "groups")

for (i in seq_len(nrow(group_matches))) {
  trn <- result(trn, "groups", match = group_matches$id[i], score = c(1, 0))
}

# ── Knockout auto-materialized (8 teams: top 2 × 4 groups) ──
stage_status(trn)
matches(trn, "knockout")

# ── Enter knockout results ... ──
# ...

winner(trn)
rankings(trn)
```

## Euro-style (per-group + best third-place)

```{r}
#| eval: false
teams_24 <- paste("Team", sprintf("%02d", 1:24))

trn <- tournament(teams_24) |>
  round_robin("groups", groups = 6) |>
  single_elim("round_of_16",
    from = "groups",
    take = c(top_per_group(2), best_across_groups(rank = 3, n = 4))
  ) |>
  single_elim("consolation", from = "groups", take = remaining())
```

## Simple linear chain

```{r}
#| eval: false
teams <- paste("Team", LETTERS[1:16])

# No from = needed — previous_stage() is the default
trn <- tournament(teams) |>
  swiss("open", rounds = 5) |>
  single_elim("top_cut", take = top_n(8))
```
