---
title: "bracketeer"
format: gfm
---

<!-- badges: start -->
<!-- badges: end -->

# bracketeer

**Tournament modeling and runtime in base R.**

`bracketeer` uses a pipe-first API: define a tournament as a chain of stage
verbs, then run it live with result entry and automatic stage advancement.

```r
library(bracketeer)

teams <- paste("Team", LETTERS[1:16])

trn <- tournament(teams) |>
  swiss("open", rounds = 5) |>
  single_elim("top_cut", take = top_n(8))
```

A tournament definition reads like a rulebook. A tournament runtime feels like
a scoreboard.

## Installation

```r
# install.packages("pak")
pak::pak("bbtheo/bracketeer")
```

## Try in Colab

Open and run the smoke-test notebook in Google Colab:

[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/bbtheo/bracketeer/blob/main/notebooks/bracketeer_smoke_test.ipynb)

## Quick Start

```r
library(bracketeer)

teams <- paste("Team", LETTERS[1:16])

# ── Define ──────────────────────────────────────────────────────────────────
trn <- tournament(teams) |>
  round_robin("groups") |>
  single_elim("finals", take = top_n(8))

# ── Enter results ────────────────────────────────────────────────────────────
trn <- trn |> result("groups", match = 1, score = c(2, 1))

# ── Inspect ──────────────────────────────────────────────────────────────────
stage_status(trn)
matches(trn, "groups", status = "pending")
standings(trn, "groups")

# When all group matches are entered, the finals stage materializes automatically.
winner(trn)
```

## The Pipe Model

Stage types are the verbs. Chaining them defines the tournament graph.

```r
# ── Single stage ─────────────────────────────────────────────────────────────
trn <- tournament(teams) |>
  round_robin("groups")

# ── Linear chain — from = previous_stage() is implicit ───────────────────────
trn <- tournament(teams) |>
  swiss("open", rounds = 5) |>
  single_elim("top_cut", take = top_n(8))

# ── Branching — explicit from = required when two stages share a source ───────
trn <- tournament(teams) |>
  round_robin("groups") |>
  single_elim("championship", from = "groups", take = top_n(8)) |>
  single_elim("consolation",  from = "groups", take = remaining())

# ── World Cup style: grouped round robin ─────────────────────────────────────
teams_32 <- paste("Team", sprintf("%02d", 1:32))

trn <- tournament(teams_32) |>
  round_robin("groups", groups = 8) |>
  single_elim("round_of_16", take = top_per_group(2))
```

## The Spec Path (Validation / Reuse)

Define a blueprint without participants, validate it, then build with a
specific set of teams.

```r
my_spec <- spec() |>
  round_robin("groups") |>
  single_elim("championship", from = "groups", take = top_n(8)) |>
  single_elim("consolation",  from = "groups", take = remaining())

validate(my_spec, n = 16)   # preflight feasibility check

trn <- my_spec |> build(teams)
```

## Entering Results

```r
# ── One at a time ─────────────────────────────────────────────────────────────
trn <- trn |> result("groups", match = 1, score = c(2, 1))

# ── Batch from a data frame ───────────────────────────────────────────────────
results_df <- data.frame(
  match  = 1:4,
  score1 = c(2, 1, 3, 0),
  score2 = c(1, 0, 2, 1)
)
trn <- trn |> results("groups", results_df)
```

`score = c(home, away)` — always a length-2+ vector. For best-of series, a
longer vector of per-game scores.

Auto-advance is the default: when the last match in a stage is entered, all
downstream stages materialize without an explicit `advance()` call.

## Inspecting State

```r
# ── Print ──────────────────────────────────────────────────────────────────────
trn
# Tournament [2 stages]
#   groups   in_progress   90/120 matches
#   finals   blocked

# ── Stage overview ─────────────────────────────────────────────────────────────
stage_status(trn)
#   stage    status        complete  total  materialized
#   groups   in_progress         90    120          TRUE
#   finals   blocked              0      0         FALSE

# ── Matches ────────────────────────────────────────────────────────────────────
matches(trn)                           # all matches, all stages
matches(trn, "groups")                 # pending in groups (default)
matches(trn, "groups", status = "all") # everything

# ── Standings ──────────────────────────────────────────────────────────────────
standings(trn, "groups")

# ── Final outcomes ─────────────────────────────────────────────────────────────
winner(trn)
rankings(trn)
routing_log(trn)
```

## Manual Advance (Opt-In)

Auto-advance is on by default. Disable it to control stage advancement
explicitly.

```r
trn <- tournament(teams, auto_advance = FALSE) |>
  round_robin("groups") |>
  single_elim("finals", take = top_n(8))

# ... enter all group results ...

trn <- trn |> advance("groups")
```

## API Reference

### Definition verbs

| Function | Purpose |
|----------|---------|
| `tournament(participants, auto_advance = TRUE)` | Create a live tournament |
| `spec()` | Create a reusable blueprint (no participants) |
| `round_robin(id, ...)` | Add round-robin stage |
| `single_elim(id, ...)` | Add single-elimination stage |
| `double_elim(id, ...)` | Add double-elimination stage |
| `swiss(id, ...)` | Add Swiss-system stage |
| `two_leg(id, ...)` | Add two-leg knockout stage |
| `group_stage_knockout(id, ...)` | Add combined group+knockout stage |

Each verb accepts `from =` (default `previous_stage()`) and `take =` (routing
rule, default: all participants from source).

### Routing helpers

| Function | Purpose |
|----------|---------|
| `top_n(n)` | Top n by overall standings |
| `bottom_n(n)` | Bottom n by overall standings |
| `slice_range(from, to)` | Standings positions from:to |
| `top_per_group(n)` | Top n from each group |
| `bottom_per_group(n)` | Bottom n from each group |
| `slice_per_group(from, to)` | Positions from:to within each group |
| `remaining()` | Participants not yet consumed by a prior transition |
| `losers()` | Eliminated participants |
| `filter_by(fn)` | Custom predicate on standings data frame |

### Runtime verbs

| Function | Purpose |
|----------|---------|
| `result(trn, stage, match, score)` | Enter one match result |
| `results(trn, stage, df)` | Enter batch results from data frame |
| `advance(trn, stage)` | Manually advance a completed stage |
| `teardown(trn, stage)` | Un-materialize a stage and all dependents |

### Inspection nouns

| Function | Purpose |
|----------|---------|
| `matches(trn, stage?, status?)` | Match table (pending/complete/all) |
| `standings(trn, stage?)` | Standings table |
| `stage_status(trn)` | Overview of all stages |
| `winner(trn)` | Tournament winner |
| `rankings(trn)` | Final placement table |
| `routing_log(trn)` | Transition audit trail |

### Spec-only

| Function | Purpose |
|----------|---------|
| `validate(spec, n)` | Preflight feasibility check |
| `build(spec, participants)` | Materialize spec into a live tournament |

## Documentation

- `vignette("tournament-lifecycle")` — Full API lifecycle walkthrough
- `vignette("fifa-world-cup")` — Group stage to knockout with `top_per_group()`
- `vignette("swiss-top-cut")` — Swiss to single-elimination linear chain
- `vignette("nhl-stanley-cup")` — Best-of-7 single elimination playoffs
- `vignette("error-catalog")` — Common errors and fixes

## License

MIT
